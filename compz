#!/usr/bin/env perl

use strict;
use warnings;

package CZ::startrule;

sub new {
    my ($class, @d) = @_;
    my $objects = $d[0];
    my $self = bless({_objects => []}, $class);
    for my $o (@{$objects}) {
        push @{$self->{_objects}}, $o->[0];
    }
    return $self;
}

sub objects {
    my ($self) = @_;
    return @{$self->{_objects}};
}

package CZ::ARGS;

sub new {
    my ($class, @d) = @_;
	shift @d;
    pop @d;
    my $self = bless({_registers => []}, $class);
    for my $reg (@{$d[0]}) {
        $reg->[0]->from_arg(1);
        push @{$self->{_registers}}, $reg->[0];
    }
    return $self;
}

sub registers {
    my ($self) = @_;
    return (); # not real registers yet
    #return (map {$_->registers} @{$self->{_registers}});
}

package CZ::ASSIGNMENT;

sub new {
    my ($class, @d) = @_;
    return bless({
        _left => $d[0]->[0],
        _right => $d[2]->[0],
    }, $class);
}

sub registers {
    my ($self) = @_;
    return ($self->{_left}->registers, $self->{_right}->registers);
}

sub code_chunk {
    my ($self) = @_;
    # if left is indirect load address into hl and value into somewhere else etc
    return CZA::CodeChunk->new();
}

package CZ::BLOCKTERMINATOR;

sub new {
    my ($class, $start) = @_;
    return bless({_start => $start}, $class);
}

sub registers {
    return ();
}

sub start {
    my ($self) = @_;
    return $self->{_start};
}

sub code_chunk {
    my ($self) = @_;
    if ($self->start->isa('CZ::LOOPBLOCK')) {
        my $type = $self->start->type;
        if ($type eq 'while') {
            return CZA::CodeChunk->new(
                ['xor', 'a'],
                ['cp x'],
                ['jp nz', $self->start->label],
            );
        }
        if ($type eq 'loop') {
            return CZA::CodeChunk->new(
                ['djnz', $self->start->label],
            );
        }
    }
    return ();
}

package CZ::BREAKCOND;

sub new {
    my ($class, @d) = @_;
    return bless({
        _test => $d[1]->[0],
        _breaks_to => undef,
    }, $class);
}

sub registers {
    my ($self) = @_;
    return ($self->{_test}->registers);
}

sub breaks_to {
    my ($self, $breaks_to) = @_;
    $self->{_breaks_to} = $breaks_to;
}

sub code_chunk {
    my ($self) = @_;
    return CZA::CodeChunk->new(
        ['ld a', '(xx)'],
        ['cp (hl)'],
        ['jp nz', $self->{_breaks_to}->label],
    );
}

# break (*16 != *16) -> ld a,(xx) : cp (hl) : jp nz,label
# break (*16 = *16)  -> ld a,(xx) : cp (hl) : jp z,label
# break (*16 != 8)   -> ld a,x : cp (hl) : jp nz,label
# break (*16 = 8)    -> ld a,x : cp (hl) : jp z,label
# break (8 != 8)     -> ld a,x : cp y : jp nz,label
# break (8 == 8)     -> ld a,x : cp y : jp z,label
# break (16 != 16)   -> and a : sbc hl,xx : add hl,xx : jp nz,label
# break (16 = 16)    -> and a : sbc hl,xx : add hl,xx : jp z,label

package CZ::CALL;

sub new {
    my ($class, @d) = @_;
    return bless({
        _name => $d[0]->[0],
        _args => $d[1]->[0],
    }, $class);
}

sub registers {
    my ($self) = @_;
    return ($self->{_args}->registers);
}

# Carrying values over call boundaries:
#
# Calls need to be surrounded by pushes and pops for their parameters, but also
# pushes and pops for variables that are live across the call boundry. When an
# argument to a procedure is 8 bit, the high byte of the 16 bit pair can be
# used to carry an 8 bit value across the call.

package CZ::COMPARITOR;

sub new {
    my ($class, @d) = @_;
    return $d[0]
}

package CZ::CONSTANT;

sub new {
    my ($class, @d) = @_;
    return bless({
        _label => $d[0]->[0],
        _value => $d[2]->[0],
    }, $class);
}

sub label {
    my ($self) = @_;
    return $self->{_label}->label;
}

sub value {
    my ($self) = @_;
    return $self->{_value}->value;
}

package CZ::DECIMAL;

sub new {
    my ($class, $decimal) = @_;
    return bless({_value => $decimal}, $class);
}

sub value {
    my ($self) = @_;
    return $self->{_value};
}

package CZ::EXPRESSION;

sub new {
    my ($class, @d) = @_;
    return $d[0]->[0];
}

package CZ::HEX16;

sub new {
    my ($class, $hex) = @_;
    return bless({_value => hex($hex)}, $class);
}

sub value {
    my ($self) = @_;
    return $self->{_value};
}

package CZ::HEX8;

sub new {
    my ($class, @d) = @_;
    die "CZ::HEX8: " . Data::Dumper::Dumper(\@d);
}

package CZ::INDIRECT;

sub new {
    my ($class, @d) = @_;
    return bless({_source => $d[1]->[0]}, $class);
}

sub source {
    my ($self) = @_;
    return $self->{_source};
}

sub registers {
    my ($self) = @_;
    return ($self->{_source}->registers);
}

package CZ::LABEL;

sub new {
    my ($class, $label) = @_;
    $label =~ s/^\.//;
    return bless({_label => $label}, $class);
}

sub registers {
    return ();
}

sub label {
    my ($self) = @_;
    return $self->{_label};
}

package CZ::LOOP;

sub new {
    my ($class, $type) = @_;
    return $type;
}

package CZ::LOOPBLOCK;

sub new {
    my ($class, @d) = @_;
    my $type = $d[0]->[0];
	my $count = $d[2]->[0];
    my $statements = $d[5];
    my $self = bless({
        _type => $type,
        _count => $count,
        _statements => [],
        _label => undef,
    }, $class);
    for my $st (@{$statements}) {
        push @{$self->{_statements}}, $st->[0];
    }
    return $self;
}

sub type {
    my ($self) = @_;
    return $self->{_type};
}

sub statements {
    my ($self) = @_;
    return @{$self->{_statements}};
}

sub label {
    my ($self) = @_;
    return $self->{_label};
}

sub generate_label {
    my ($self, $proc_short_name, $idx) = @_;
    $self->{_label} = sprintf('%s_l%d', $proc_short_name, $idx);
}

sub statements_flat {
    my ($self) = @_;
    my @statements = $self->statements;
    my @flat;
    push @flat, $self;
    for my $statement (@statements) {
        if ($statement->can('statements_flat')) {
            push @flat, $statement->statements_flat;
            next;
        }
        push @flat, $statement;
    }
    push @flat, CZ::BLOCKTERMINATOR->new($self);
    return @flat;
}

sub registers {
    my ($self) = @_;
    return ($self->{_count}->registers);
}

sub code_chunk {
    my ($self) = @_;
    return CZA::Label->new($self->label);
}

package CZ::MUTATOR;

sub new {
    my ($class, @d) = @_;
    return bless({
        _operator => $d[0],
        _value => $d[1]->[0],
    }, $class);
}

sub registers {
    my ($self) = @_;
    return ($self->{_value}->registers);
}

sub code_chunk {
    my ($self) = @_;
    my $value;
    if ($self->{_value}->isa('CZ::REG8')) {
        $value = $self->{_value}->name;
    }
    elsif ($self->{_value}->isa('CZ::REG16')) {
        $value = $self->{_value}->name;
    }
    elsif ($self->{_value}->isa('CZ::INDIRECT')) {
        $value = $self->{_value}->source->name;
    }
    else {
        die "invalid mutator";
    }
    if ($self->{_operator} eq '++') {
        return CZA::CodeChunk->new(['inc ' . $value]);
    }
    if ($self->{_operator} eq '--') {
        return CZA::CodeChunk->new(['dec ' . $value]);
    }
}

package CZ::NAMESPACE;

sub new {
    my ($class, @d) = @_;
    return bless({_namespace => $d[1]->[0]}, $class);
}

sub namespace {
    my ($self) = @_;
    return $self->{_namespace};
}

package CZ::NUMBER;

sub new {
    my ($class, @d) = @_;
    return bless({_value => $d[0]->[0]}, $class);
}

sub registers {
    return ();
}

sub value {
    my ($self) = @_;
    return $self->{_value}->value;
}

package CZ::OBJECT;

sub new {
    my ($class, @d) = @_;
    return $d[0]->[0];
}

package CZ::OP;

sub new {
    my ($class, $op) = @_;
    return $op;
}

package CZ::POST;

sub new {
    my ($class, @d) = @_;
    return bless({}, $class);
}

sub registers {
    return ();
}

sub code_chunk {
    my ($self) = @_;
    return CZA::CodeChunk->new();
}

package CZ::POSTTERMINATOR;

sub new {
    my ($class, @d) = @_;
    return bless({_label => undef}, $class);
}

sub registers {
    return ();
}

sub label {
    my ($self) = @_;
    return $self->{_label};
}

sub code_chunk {
    my ($self) = @_;
    return CZA::Label->new($self->label);
}

sub generate_label {
    my ($self, $proc_short_name, $idx) = @_;
    $self->{_label} = sprintf('%s_p%d', $proc_short_name, $idx);
}

package CZ::PROCEDURE;

sub new {
    my ($class, @d) = @_;
    my $nr_parts = scalar(@d);
    if ($nr_parts == 7) {
        my $ret = $d[0]->[0];
        my $name = $d[2]->[0];
        my $args = $d[3]->[0];
        my $statements = $d[5];
        my $self = bless({
            _return => $ret,
            _name => $name,
            _args => $args,
            _statements => []
        }, $class);
        for my $st (@{$statements}) {
            push @{$self->{_statements}}, $st->[0];
        }
        return $self;
    }
    if ($nr_parts == 6) {
        my $ret = $d[0]->[0];
        my $name = $d[2]->[0];
        my $args = undef;
        my $statements = $d[4];
        my $self = bless({
            _return => $ret,
            _name => $name,
            _args => $args,
            _statements => []
        }, $class);
        for my $st (@{$statements}) {
            push @{$self->{_statements}}, $st->[0];
        }
        return $self;
    }
    if ($nr_parts == 5) {
        my $ret = undef;
        my $name = $d[0]->[0];
        my $args = $d[1]->[0];
        my $statements = $d[3];
        my $self = bless({
            _return => $ret,
            _name => $name,
            _args => $args,
            _statements => []
        }, $class);
        for my $st (@{$statements}) {
            push @{$self->{_statements}}, $st->[0];
        }
        return $self;
    }
    if ($nr_parts == 4) {
        my $ret = undef;
        my $name = $d[0]->[0];
        my $args = undef;
        my $statements = $d[2];
        my $self = bless({
            _return => $ret,
            _name => $name,
            _args => $args,
            _statements => []
        }, $class);
        for my $st (@{$statements}) {
            push @{$self->{_statements}}, $st->[0];
        }
        return $self;
    }
}

sub return {
    my ($self) = @_;
    return $self->{_return};
}

sub name {
    my ($self) = @_;
    return $self->{_name};
}

sub args {
    my ($self) = @_;
    return $self->{_args};
}

sub statements {
    my ($self) = @_;
    return @{$self->{_statements}};
}

sub statements_flat {
    my ($self) = @_;
    my @statements = $self->statements;
    my @flat;
    push @flat, $self;
    for my $statement (@statements) {
        if ($statement->can('statements_flat')) {
            push @flat, $statement->statements_flat;
            next;
        }
        push @flat, $statement;
    }
    return @flat;
}

sub registers {
    my ($self) = @_;
    return (($self->{_args}) ? $self->{_args}->registers : ());
}

sub code_chunk {
    my ($self) = @_;
    return CZA::Label->new($self->name);
};

package CZ::REG16;

sub new {
    my ($class, $register) = @_;
    return bless({
        _name => $register,
        _from_arg => 0,
    }, $class);
}

sub name {
    my ($self) = @_;
    return $self->{_name};
}

sub registers {
    my ($self) = @_;
    return ($self);
}

sub from_arg {
    my ($self, $from_arg) = @_;
    $self->{_from_arg} = $from_arg if defined $from_arg;
    return $self->{_from_arg};
}

package CZ::REG8;

sub new {
    my ($class, $register) = @_;
    return bless({
        _name => $register,
        _from_arg => 0,
    }, $class);
}

sub name {
    my ($self) = @_;
    return $self->{_name};
}

sub registers {
    my ($self) = @_;
    return ($self);
}

sub from_arg {
    my ($self, $from_arg) = @_;
    $self->{_from_arg} = $from_arg if defined $from_arg;
    return $self->{_from_arg};
}

package CZ::REGISTER;

sub new {
    my ($class, @d) = @_;
    return $d[0]->[0];
}

package CZ::RETURN;

sub new {
    my ($class, @d) = @_;
    return bless({_value => $d[1]->[0]}, $class);
}

sub value {
    my ($self) = @_;
    return $self->{_value};
}

sub registers {
    my ($self) = @_;
    return ($self->{_value}->registers);
}

sub code_chunk {
    my ($self) = @_;
    if ($self->value->isa('CZ::REG8')) {
        return CZA::CodeChunk->new(
            ['ld h', '0x00'],
            ['ld l', $self->value->name],
            ['ret'],
        );
    }
    if ($self->value->isa('CZ::REG16')) {
        return CZA::CodeChunk->new(
            ['ld hl', $self->value->name],
            ['ret'],
        );
    }
    die "invalid return";
}

package CZ::STATEMENT;

sub new {
    my ($class, @d) = @_;
    return $d[0]->[0];
}

package CZ::TERNARY;

sub new {
    my ($class, @d) = @_;
    die "CZ::TERNARY " . Data::Dumper::Dumper(\@d);
}

package CZ::TEST;

sub new {
    my ($class, @d) = @_;
	shift @d;
    pop @d;
    return bless({
        _left => $d[0]->[0],
        _comparitor => $d[1]->[0],
        _right => $d[2]->[0],
    }, $class);
}

sub registers {
    my ($self) = @_;
    return ($self->{_left}->registers, $self->{_right}->registers);
}

package CZ::VALOPVAL;

sub new {
    my ($class, @d) = @_;
    return bless({
        _left => $d[0]->[0],
        _op => $d[1]->[0],
        _right => $d[2]->[0],
    }, $class);
}

sub registers {
    my ($self) = @_;
    return ($self->{_left}->registers, $self->{_right}->registers);
}

package CZ::VALUE;

sub new {
    my ($class, @d) = @_;
    return $d[0]->[0];
}

package CZ::VARIABLE;

sub new {
    my ($class, @d) = @_;
    return $d[0]->[0];
}

package CZ::WORD;

sub new {
    my ($class, @d) = @_;
    return $d[0];
}

package CZA::Block;

sub new {
    my ($class, @statements) = @_;
    my $self = bless({
        _statements => [],
        _code_chunks => [],
    }, $class);
    for my $statement (@statements) {
        push @{$self->{_statements}}, $statement;
    }
    return $self;
}

sub statements {
    my ($self) = @_;
    return @{$self->{_statements}};
}

sub entry {
    my ($self) = @_;
    return $self->{_statements}->[0];
}

sub code_chunks {
    my ($self) = @_;
    return @{$self->{_code_chunks}};
}

sub generate_labels {
    my ($self, $proc_short_name, $label_idx) = @_;
    for my $statement ($self->statements) {
        if ($statement->can('generate_label')) {
            $statement->generate_label($proc_short_name, $label_idx);
            $label_idx++;
        }
    }
    return $label_idx;
}

sub generate_codes {
    my ($self) = @_;
    for my $statement ($self->statements) {
        push @{$self->{_code_chunks}}, $statement->code_chunk;
    }
}

sub add_posterminator {
    my ($self) = @_;
    my $posterminator = CZ::POSTTERMINATOR->new;
    push @{$self->{_statements}}, $posterminator;
    return $posterminator;
}

sub uniq_registers {
    my ($self) = @_;
    my %uniq_registers;
    for my $statement ($self->statements) {
        for my $register ($statement->registers) {
            $uniq_registers{$register->name} = $register;
        }
    }
    return sort {$a->name cmp $b->name} values %uniq_registers;
}

package CZA::Label;

sub new {
    my ($class, $label) = @_;
    return bless({_label => $label}, $class);
}

sub stringify {
    my ($self) = @_;
    return $self->{_label} . ":";
}

package CZA::CodeChunk;

sub new {
    my ($class, @codes) = @_;
    my $self = bless({_codes => []}, $class);
    for my $code (@codes) {
        push @{$self->{_codes}}, $code;
    }
    return $self;
}

sub stringify {
    my ($self) = @_;
    my @lines;
    for my $code (@{$self->{_codes}}) {
        push @lines, join(',', @{$code});
    }
    return @lines;
}

package CZ;

use Data::Dumper;
use Parse::RecDescent;

$Data::Dumper::Indent = 1;
$Data::Dumper::Trailingcomma = 1;
$Data::Dumper::Quotekeys = 0;
$Data::Dumper::Sortkeys = 1;

sub new {
    my ($class) = @_;
    return bless({}, $class);
}

sub parser {
    my ($self) = @_;
    #$::RD_ERRORS = 1; # Make sure the parser dies when it encounters an error
    #$::RD_WARN   = 1; # Enable warnings. This will warn on unused rules &c.
    #$::RD_HINT   = 1; # Give out hints to help fix problems.
    #$::RD_TRACE  = 1;
    $::RD_AUTOACTION = q{[main::builder(@item)]};
    $/ = undef;
    my $grammar = <main::DATA>;
    return Parse::RecDescent->new($grammar),
}

sub stdin {
    my ($self) = @_;
    my $code = "";
    while (my $l = <STDIN>) {
        $code .= $l;
    }
    my $startrule = $self->parser->startrule($code);
    my $ast = $startrule->[0];
    return $self->process($ast);
}

sub ident {
    my ($self, $ident) = @_;
    return ($self->{_namespace})
        ? sprintf('%s_%s', $self->{_namespace}, $ident)
        : $ident;
}

sub process {
    my ($self, $ast) = @_;
    if (!$ast->isa('CZ::startrule')) {
        die "no startrule found";
    }
    for my $object ($ast->objects) {
        if ($object->isa('CZ::NAMESPACE')) {
            $self->{_namespace} = $object->namespace;
            next;
        }
        if ($object->isa('CZ::CONSTANT')) {
            $self->process_constant($object);
            next;
        }
        if ($object->isa('CZ::PROCEDURE')) {
            $self->process_procedure($object);
            next;
        }
    }
}

sub process_constant {
    my ($self, $object) = @_;
    printf("%s: equ %s\n", $self->ident($object->label), $object->value);
}

# Move POST blocks after the BLOCKTERMINATOR of the end of a loop. The
# BLOCKTERMINATOR of a LOOPBLOCK will be the test and jump. The POST should be
# the fall-through of that test. A BREAKCOND inside the loop will jump over the
# post to the BLOCKTERMINATOR.
#
sub swap_posts {
    my ($self, @blocks) = @_;
    my @new_blocks;
    my $post_block;
    for my $block (@blocks) {
        if ($block->entry->isa('CZ::POST')) {
            $post_block = $block;
            next;
        }
        push @new_blocks, $block;
        if ($post_block) {
            push @new_blocks, $post_block;
            $post_block = undef;
        }
    }
    return @new_blocks;
}

# Search inside LOOPBLOCKs for all BREAKCONDs. If found remember them and
# continue to the next BLOCKTERMINATOR. When found mark that as the destination
# for the break jump, and also inform the BLOCKTERMINATOR that it needs to
# become a destination label (otherwise BLOCKTERMINATORs don't need labels).
#
sub link_breaks {
    my ($self, @blocks) = @_;
    my @prev_breakconds;
    for my $block (@blocks) {
        my $entry = $block->entry;
        if ($entry->isa('CZ::POST') && @prev_breakconds) {
            my $posterminator = $block->add_posterminator;
            for my $breakcond (@prev_breakconds) {
                $breakcond->breaks_to($posterminator);
            }
            @prev_breakconds = ();
            next;
        }
        if (!$entry->isa('CZ::LOOPBLOCK')) {
            next;
        }
        @prev_breakconds = grep {$_->isa('CZ::BREAKCOND')} $block->statements;
    }
}

# Now the blocks are in order and objects have been linked to their
# destinations, we can generate labels.
#
sub generate_labels {
    my ($self, $proc_short_name, @blocks) = @_;
    my $label_idx = 0;
    for my $block (@blocks) {
        $label_idx = $block->generate_labels($proc_short_name, $label_idx);
    }
}

sub generate_codes {
    my ($self, @blocks) = @_;
    for my $block (@blocks) {
        $block->generate_codes;
    }
}

sub generate_shorthand {
    my ($long) = @_;
    my @parts = split(/_/, $long);
    my @shortp;
    for my $part (@parts) {
        my @chars = split(//, $part);
        push @shortp, (scalar(@chars) > 1) ? $chars[0] . $chars[1] : $chars[0];
    }
    return join('', @shortp);
}

sub process_procedure {
    my ($self, $object) = @_;

    # Flatten out all statements into one list
    my @statements_flat = $object->statements_flat;
    if (!$statements_flat[0]->isa('CZ::PROCEDURE')) {
        die "PROCEDURE not found";
    }
    my $proc_short_name = generate_shorthand($statements_flat[0]->name);

    # Group the statements into blocks.
    my @blocks;
    my @temp;
    for my $statement (@statements_flat) {
        if (
            $statement->isa('CZ::LOOPBLOCK') ||
            $statement->isa('CZ::POST') ||
            $statement->isa('CZ::BLOCKTERMINATOR')
        ) {
            push @blocks, CZA::Block->new(@temp);
            @temp = ();
        }
        push @temp, $statement;
    }
    push @blocks, CZA::Block->new(@temp);

    # Move the POSTs to after the loop ends
    @blocks = $self->swap_posts(@blocks);

    # Connect breaks to the place they should jump to
    $self->link_breaks(@blocks);

    # Generate labels for things that need them
    $self->generate_labels($proc_short_name, @blocks);

    # Generate the assembly code
    $self->generate_codes(@blocks);

    for my $block (@blocks) {
        my @registers = $block->uniq_registers;
        print "; REGISTERS: " . join(", ", map {$_->name} @registers) . "\n";
        my @statements = $block->statements;
        print "; block start: " . ref($statements[0]) . "\n";
        for my $code_chunk ($block->code_chunks) {
            my @lines = $code_chunk->stringify;
            my $indent = $code_chunk->isa('CZA::CodeChunk') ? "    " : "";
            for my $line (@lines) {
                print $indent . $line . "\n";
            }
        }
    }

    #    print ref($statement) . "\n";
    #    next;
    #    my @registers = $statement->registers;
    #    for my $register (@registers) {
    #        my $name = $register->name;
    #        push @{$register_map[$idx]}, $name;
    #    }
    #    $idx++;
    #}
}

package main;

sub builder {
    my (@item) = @_;
    my $type = shift @item;
    my $class = sprintf('CZ::%s', $type);
    return $class->new(@item);
}

my $cz = CZ->new;
$cz->stdin;

__DATA__
REG16       : /[a-z]{2}/
REG8        : /[a-z]/
WORD        : /[a-z0-9_]{3,}/
LABEL       : /.[a-z0-9_]+/
COMPARITOR  : '==' | '!='
OP          : '+' | '-' | '/' | '*'
HEX16       : /0x[0-9a-f]{4}/
HEX8        : /0x[0-9a-f]{2}/
DECIMAL     : /[0-9]+/
POST        : '|'
LOOP        : 'loop' | 'while'

REGISTER : REG16 | REG8

NUMBER : HEX16
       | HEX8
       | DECIMAL

INDIRECT : '*' REG16

VARIABLE : INDIRECT
         | REGISTER

VALUE : VARIABLE
      | LABEL
      | NUMBER

CONSTANT : LABEL '=' NUMBER

ARGS : '[' REGISTER(s) ']'

TEST : '(' VALUE COMPARITOR VALUE ')'

TERNARY : TEST '?' EXPRESSION ':' EXPRESSION

BREAKCOND : 'break' TEST

CALL : WORD ARGS

VALOPVAL: VALUE OP VALUE

EXPRESSION : INDIRECT
           | TERNARY
           | CALL
           | VALOPVAL
           | VALUE

MUTATOR : '++' VARIABLE
        | '--' VARIABLE

RETURN : '<=' EXPRESSION

LOOPBLOCK : LOOP '[' REGISTER ']' '{' STATEMENT(s) '}'

ASSIGNMENT : VARIABLE '=' EXPRESSION

STATEMENT : RETURN
          | MUTATOR
          | POST
          | BREAKCOND
          | LOOPBLOCK
          | ASSIGNMENT

PROCEDURE : REGISTER '<=' WORD ARGS '{' STATEMENT(s) '}'
          | REGISTER '<=' WORD '{' STATEMENT(s) '}'
          | WORD ARGS '{' STATEMENT(s) '}'
          | WORD '{' STATEMENT(s) '}'

NAMESPACE : 'namespace' WORD

OBJECT : NAMESPACE
       | CONSTANT
       | PROCEDURE

startrule : OBJECT(s)
